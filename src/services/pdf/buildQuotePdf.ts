// src/pdf/buildQuotePdf.ts
import PDFDocument from 'pdfkit';
import { IQuote } from '../../models/Quote';
import { capitalizeFirstWord } from '../../utils/capitalizeFirstWord';
import fs from 'fs';
import path from 'path';

export const buildQuotePdf = async (doc: typeof PDFDocument, quote: IQuote, qrBuffer: Buffer) => {
  let currentPageNumber = 1;
  const footerAddedPages = new Set<number>();
  doc.registerFont('NotoSans', path.join(__dirname, '../../assets/fonts/NotoSans-Regular.ttf'));

  // Track all pages created during rendering
  let actualPageCount = 0;
  const originalAddPage = doc.addPage.bind(doc);
  doc.addPage = function (...args: any[]) {
    actualPageCount++;
    return originalAddPage(...args);
  };

  // ============ ENHANCED COLOR PALETTE ============
  const colors = {
    primary: '#1E3A8A',
    secondary: '#3B82F6',
    darkText: '#0F172A',
    mediumText: '#475569',
    lightText: '#6B7280',
    sectionBg: '#F9FAFB',
    borderColor: '#D1D5DB',
    accentGreen: '#059669',
    accentBlue: '#0EA5E9',
    accentPurple: '#7C3AED',
    warningAmber: '#D97706',
    successGreen: '#10B981',
    white: '#FFFFFF',
  };

  const pageWidth = 595.28;
  const pageHeight = 841.89;
  const margin = 50;
  const contentWidth = pageWidth - margin * 2;
  const footerHeight = 80; // Reserved space for footer
  const safeBottomY = pageHeight - margin - footerHeight;

  // Current Y position tracker
  let currentY = margin;

  // ============ HELPER FUNCTIONS ============

  const addFooter = (pageNum: number) => {
    doc
      .fontSize(10)
      .fillColor(colors.lightText)
      .font('Helvetica')
      .text('Auto-generated by Trakshym Estimator v1.0', margin, pageHeight - 74, {
        width: contentWidth / 3,
      })
      .fontSize(10)
      .fillColor(colors.lightText)
      .text(quote.publicId, margin + contentWidth / 3, pageHeight - 74, {
        width: contentWidth / 3,
        align: 'center',
      })
      .fontSize(10)
      .fillColor(colors.lightText)
      .text(`Page ${pageNum}`, margin + (contentWidth * 2) / 3, pageHeight - 74, {
        width: contentWidth / 3,
        align: 'right',
      });
  };

  const addFooterToCurrentPage = () => {
    if (!footerAddedPages.has(currentPageNumber)) {
      addFooter(currentPageNumber);
      footerAddedPages.add(currentPageNumber);
    }
  };

  const drawDivider = (y: number, color = colors.borderColor, thickness = 1) => {
    doc
      .strokeColor(color)
      .lineWidth(thickness)
      .moveTo(margin, y)
      .lineTo(pageWidth - margin, y)
      .stroke();
  };

  const drawSectionBox = (
    x: number,
    y: number,
    width: number,
    height: number,
    bgColor: string,
    borderCol = colors.primary,
    radius = 12
  ) => {
    if ((doc as any)._pdfkitRoundedRect) {
      doc.roundedRect(x, y, width, height, radius).fillAndStroke(bgColor, borderCol);
    } else {
      doc.rect(x, y, width, height).fillAndStroke(bgColor, borderCol);
    }
  };

  const getValidityDate = () => {
    const date = new Date();
    date.setDate(date.getDate() + 30);
    return date;
  };

  const addRoundedImage = (
    imageBuffer: Buffer,
    x: number,
    y: number,
    width: number,
    height: number,
    radius: number = 8
  ) => {
    doc.save();
    doc.roundedRect(x, y, width, height, radius).clip();
    doc.image(imageBuffer, x, y, { width, height });
    doc.restore();
  };

  const drawRupeesText = (
    text: string,
    x: number,
    y: number,
    options: { fontSize?: number; fillColor?: string }
  ) => {
    doc
      .font('NotoSans')
      .fontSize(options.fontSize || 12)
      .fillColor(options.fillColor || colors.darkText)
      .text(text, x, y);
  };

  // ============ DYNAMIC PAGE MANAGEMENT HELPERS ============

  /**
   * Check if we have enough space on current page
   */
  const hasSpaceFor = (requiredHeight: number): boolean => {
    return currentY + requiredHeight <= safeBottomY;
  };

  /**
   * Get remaining space on current page
   */
  const getRemainingSpace = (): number => {
    return Math.max(0, safeBottomY - currentY);
  };

  /**
   * Add a new scope continuation page
   */
  const addScopeContinuationPage = (sectionTitle?: string) => {
    addFooterToCurrentPage();
    doc.addPage();
    currentPageNumber++;
    currentY = margin;

    if (sectionTitle) {
      doc
        .fontSize(16)
        .font('Helvetica-Bold')
        .fillColor(colors.primary)
        .text(`${sectionTitle} (CONTINUED)`, margin, currentY);

      currentY += 25;
      drawDivider(currentY);
      currentY += 15;
    }
  };

  /**
   * Ensure minimum space, add new page if needed
   */
  const ensureSpace = (requiredHeight: number, sectionTitle?: string): void => {
    if (!hasSpaceFor(requiredHeight)) {
      addScopeContinuationPage(sectionTitle);
    }
  };

  /**
   * Measure text height before rendering
   */
  const measureTextHeight = (
    text: string,
    fontSize: number,
    font: string,
    width: number,
    lineGap: number = 3
  ): number => {
    doc.fontSize(fontSize).font(font);
    const textHeight = doc.heightOfString(text, {
      width: width,
      lineGap: lineGap,
    });
    return textHeight;
  };

  /**
   * Render text with automatic page breaks
   * Returns the final Y position after rendering
   */
  const renderTextWithPageBreaks = (
    text: string,
    options: {
      fontSize: number;
      font: string;
      color: string;
      width?: number;
      lineGap?: number;
      align?: 'left' | 'center' | 'right' | 'justify';
      indent?: number;
      sectionTitle?: string;
    }
  ): void => {
    const {
      fontSize,
      font,
      color,
      width = contentWidth,
      lineGap = 3,
      align = 'justify',
      indent = 0,
      sectionTitle = 'PROJECT SCOPE',
    } = options;

    const xPos = margin + indent;
    const effectiveWidth = width - indent;

    // Split text into paragraphs
    const paragraphs = text.split('\n').filter((p) => p.trim());

    paragraphs.forEach((paragraph, pIdx) => {
      // Measure paragraph height
      const paragraphHeight = measureTextHeight(paragraph, fontSize, font, effectiveWidth, lineGap);

      // Check if we can fit at least the first line
      const minLineHeight = fontSize + lineGap + 10;

      if (!hasSpaceFor(minLineHeight)) {
        addScopeContinuationPage(sectionTitle);
      }

      // If entire paragraph fits, render it
      if (hasSpaceFor(paragraphHeight)) {
        doc
          .fontSize(fontSize)
          .font(font)
          .fillColor(color)
          .text(paragraph, xPos, currentY, {
            width: effectiveWidth,
            align: align,
            lineGap: lineGap,
          });
        currentY = doc.y + (pIdx < paragraphs.length - 1 ? 8 : 0);
      } else {
        // Need to split paragraph across pages
        const words = paragraph.split(' ');
        let remainingWords = [...words];

        while (remainingWords.length > 0) {
          const availableHeight = getRemainingSpace();

          // Build text that fits in available space
          let fittingText = '';
          let wordsUsed = 0;

          for (let i = 0; i < remainingWords.length; i++) {
            const testText = fittingText
              ? `${fittingText} ${remainingWords[i]}`
              : remainingWords[i];
            const testHeight = measureTextHeight(testText, fontSize, font, effectiveWidth, lineGap);

            if (testHeight <= availableHeight - 10) {
              fittingText = testText;
              wordsUsed = i + 1;
            } else {
              break;
            }
          }

          // Ensure we always render at least one word
          if (wordsUsed === 0 && remainingWords.length > 0) {
            fittingText = remainingWords[0];
            wordsUsed = 1;
          }

          // Render the fitting text
          if (fittingText) {
            doc
              .fontSize(fontSize)
              .font(font)
              .fillColor(color)
              .text(fittingText, xPos, currentY, {
                width: effectiveWidth,
                align: align,
                lineGap: lineGap,
              });
            currentY = doc.y;
          }

          // Remove used words
          remainingWords = remainingWords.slice(wordsUsed);

          // If more words remain, go to next page
          if (remainingWords.length > 0) {
            addScopeContinuationPage(sectionTitle);
          }
        }

        if (pIdx < paragraphs.length - 1) {
          currentY += 8;
        }
      }
    });
  };

  /**
   * Render a list of items with automatic page breaks
   */
  const renderListWithPageBreaks = (
    items: string[],
    options: {
      fontSize: number;
      font: string;
      color: string;
      bulletPrefix?: string;
      lineHeight?: number;
      indent?: number;
      sectionTitle?: string;
    }
  ): void => {
    const {
      fontSize,
      font,
      color,
      bulletPrefix = '• ',
      lineHeight = 16,
      indent = 10,
      sectionTitle = 'PROJECT SCOPE',
    } = options;

    items.forEach((item) => {
      const itemText = `${bulletPrefix}${item}`;
      const itemHeight = measureTextHeight(itemText, fontSize, font, contentWidth - indent, 2);
      const requiredHeight = Math.max(lineHeight, itemHeight + 4);

      ensureSpace(requiredHeight, sectionTitle);

      doc
        .fontSize(fontSize)
        .font(font)
        .fillColor(color)
        .text(itemText, margin + indent, currentY, {
          width: contentWidth - indent,
          lineGap: 2,
        });

      currentY = doc.y + 4;
    });
  };

  /**
   * Render section header
   */
  const renderSectionHeader = (
    title: string,
    options: {
      fontSize?: number;
      topMargin?: number;
      bottomMargin?: number;
      showDivider?: boolean;
      dividerColor?: string;
      sectionTitle?: string;
    } = {}
  ): void => {
    const {
      fontSize = 14,
      topMargin = 0,
      bottomMargin = 20,
      showDivider = true,
      dividerColor = colors.borderColor,
      sectionTitle = 'PROJECT SCOPE',
    } = options;

    const headerHeight = fontSize + bottomMargin + (showDivider ? 15 : 0);
    ensureSpace(headerHeight + 40, sectionTitle); // +40 for at least some content

    currentY += topMargin;

    doc
      .fontSize(fontSize)
      .font('Helvetica-Bold')
      .fillColor(colors.darkText)
      .text(title, margin, currentY);

    currentY += fontSize + 6;

    if (showDivider) {
      drawDivider(currentY, dividerColor);
      currentY += 12;
    }
  };

  // ============ PAGE 1: COVER & EXECUTIVE SUMMARY ============

  // Header background
  doc.rect(0, 0, pageWidth, 180).fill(colors.darkText);

  // Logo
  let logoWidth = 60;
  let logoHeight = 60;
  let logoX = margin;
  let logoY = 40;

  try {
    const logoPath = path.join(process.cwd(), 'src/assets/logo.png');
    const logoBuffer = await fs.promises.readFile(logoPath);
    addRoundedImage(logoBuffer, logoX, logoY, logoWidth, logoHeight, 10);
  } catch (err) {
    console.error('Logo not found:', err);
  }

  // Title text
  const textX = logoX + logoWidth + 20;
  const textY = logoY + logoHeight / 2 - 12;

  doc.fontSize(32).fillColor(colors.white).font('Helvetica-Bold').text('TRAKSHYM', textX, textY);

  doc
    .fontSize(24)
    .fillColor(colors.white)
    .font('Helvetica-Bold')
    .text('PROJECT ESTIMATION REPORT', margin, 130, { width: contentWidth });

  currentY = 230;

  // Metadata cards
  const metaBoxWidth = (contentWidth - 20) / 3;
  const metaBoxHeight = 76;
  const validityDate = getValidityDate();

  // Box 1: Quote Number
  drawSectionBox(margin, currentY, metaBoxWidth, metaBoxHeight, colors.white, colors.primary);
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Quote Number', margin + 15, currentY + 20, { width: metaBoxWidth - 30 })
    .fontSize(14)
    .fillColor(colors.primary)
    .font('Helvetica-Bold')
    .text(quote.publicId, margin + 15, currentY + 45, { width: metaBoxWidth - 30 });

  // Box 2: Generated Date
  const box2X = margin + metaBoxWidth + 10;
  drawSectionBox(box2X, currentY, metaBoxWidth, metaBoxHeight, colors.white, colors.accentBlue);
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Generated', box2X + 15, currentY + 20, { width: metaBoxWidth - 30 })
    .fontSize(14)
    .fillColor(colors.accentBlue)
    .font('Helvetica-Bold')
    .text(
      new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' }),
      box2X + 15,
      currentY + 45,
      { width: metaBoxWidth - 30 }
    );

  // Box 3: Valid Until
  const box3X = margin + metaBoxWidth * 2 + 20;
  drawSectionBox(box3X, currentY, metaBoxWidth, metaBoxHeight, colors.white, colors.warningAmber);
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Valid Until', box3X + 15, currentY + 20, { width: metaBoxWidth - 30 })
    .fontSize(14)
    .fillColor(colors.warningAmber)
    .font('Helvetica-Bold')
    .text(
      validityDate.toLocaleDateString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
      }),
      box3X + 15,
      currentY + 45,
      { width: metaBoxWidth - 30 }
    );

  currentY += 110;

  // Client Details
  doc
    .fontSize(16)
    .font('Helvetica-Bold')
    .fillColor(colors.darkText)
    .text('CLIENT DETAILS', margin, currentY);

  currentY += 25;
  drawDivider(currentY);
  currentY += 15;

  // Left column
  doc.fontSize(11).fillColor(colors.mediumText).font('Helvetica').text('Name:', margin, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.darkText)
    .font('Helvetica-Bold')
    .text(quote.client.name, margin + 60, currentY);

  currentY += 20;
  doc.fontSize(11).fillColor(colors.mediumText).font('Helvetica').text('Email:', margin, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.darkText)
    .font('Helvetica-Bold')
    .text(quote.client.email, margin + 60, currentY);

  currentY += 20;
  doc.fontSize(11).fillColor(colors.mediumText).font('Helvetica').text('Phone:', margin, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.darkText)
    .font('Helvetica-Bold')
    .text(quote.client.phone, margin + 60, currentY);

  currentY += 20;
  if (quote.client.company) {
    doc
      .fontSize(11)
      .fillColor(colors.mediumText)
      .font('Helvetica')
      .text('Company:', margin, currentY);
    doc
      .fontSize(12)
      .fillColor(colors.darkText)
      .font('Helvetica-Bold')
      .text(quote.client.company, margin + 60, currentY);
    currentY += 20;
  }

  // Right column
  const rightColX = margin + contentWidth / 2;
  currentY -= quote.client.company ? 80 : 60;

  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Engagement Model:', rightColX, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.primary)
    .font('Helvetica-Bold')
    .text(quote.engagementModel.toUpperCase(), rightColX + 140, currentY);

  currentY += 20;
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('User Profile:', rightColX, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.primary)
    .font('Helvetica-Bold')
    .text(quote.userProfile.toUpperCase(), rightColX + 140, currentY);

  currentY += 20;
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Status:', rightColX, currentY);
  doc
    .fontSize(12)
    .fillColor(quote.status === 'final' ? colors.accentGreen : colors.warningAmber)
    .font('Helvetica-Bold')
    .text(quote.status.toUpperCase(), rightColX + 140, currentY);

  currentY += 20;
  doc
    .fontSize(11)
    .fillColor(colors.mediumText)
    .font('Helvetica')
    .text('Version:', rightColX, currentY);
  doc
    .fontSize(12)
    .fillColor(colors.darkText)
    .font('Helvetica-Bold')
    .text(quote.version.toString(), rightColX + 140, currentY);

  currentY += 45;

  // Executive Summary
  doc
    .fontSize(16)
    .font('Helvetica-Bold')
    .fillColor(colors.darkText)
    .text('EXECUTIVE SUMMARY', margin, currentY);

  currentY += 20;
  drawDivider(currentY);
  currentY += 15;

  const summaryText = `This comprehensive project estimation report outlines the scope, timeline, and commercials for developing ${quote.inputs.buildTypes.join(', ')}. We have analyzed your requirements across ${quote.inputs.features.length} features and prepared three delivery options tailored to different priorities: cost optimization, balanced approach, and fast-track delivery.`;

  doc
    .fontSize(11)
    .font('Helvetica')
    .fillColor(colors.mediumText)
    .text(summaryText, margin, currentY, { width: contentWidth, align: 'justify', lineGap: 4 });

  // Add footer to page 1
  addFooterToCurrentPage();

  // ============ PAGE 2+: PROJECT SCOPE (FULLY DYNAMIC) ============
  doc.addPage();
  currentPageNumber++;
  currentY = margin;

  // Page header
  doc
    .fontSize(24)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text('PROJECT SCOPE', margin, currentY);

  currentY += 35;
  drawDivider(currentY, colors.primary, 2);
  currentY += 25;

  // ============ PROJECT GOALS (DYNAMIC) ============
  renderSectionHeader('Project Goals & Objectives', {
    fontSize: 14,
    showDivider: false,
    sectionTitle: 'PROJECT SCOPE',
  });

  renderTextWithPageBreaks(quote.inputs.goals || 'No specific goals defined.', {
    fontSize: 11,
    font: 'Helvetica',
    color: colors.mediumText,
    lineGap: 3,
    align: 'justify',
    sectionTitle: 'PROJECT SCOPE',
  });

  currentY += 25;

  // ============ DELIVERABLES (DYNAMIC) ============
  const boxWidth = (contentWidth - 16) / 2;
  const itemLineH = 16;
  const boxTopPadding = 12;
  const boxBottomPadding = 16;
  const boxHeaderH = 20;
  const buildTypesCount = (quote.inputs.buildTypes || []).length;
  const artifactsCount = (quote.inputs.artifacts || []).length;
  const buildBoxH = Math.max(
    60,
    boxTopPadding + boxHeaderH + buildTypesCount * itemLineH + boxBottomPadding
  );
  const artBoxH = Math.max(
    60,
    boxTopPadding + boxHeaderH + artifactsCount * itemLineH + boxBottomPadding
  );
  const boxHeight = Math.max(buildBoxH, artBoxH);

  // Check if we have space for Deliverables section
  const deliverablesSectionHeight = 20 + boxHeight + 25;
  ensureSpace(deliverablesSectionHeight, 'PROJECT SCOPE');

  renderSectionHeader('Deliverables', {
    fontSize: 14,
    showDivider: false,
    sectionTitle: 'PROJECT SCOPE',
  });

  // Build Types Box
  drawSectionBox(margin, currentY, boxWidth, boxHeight, colors.sectionBg, colors.primary);
  doc
    .fontSize(13)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text('Build Types', margin + 15, currentY + 12);

  let btY = currentY + 35;
  quote.inputs.buildTypes.forEach((type: string) => {
    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.darkText)
      .text(`• ${type}`, margin + 15, btY);
    btY += itemLineH;
  });

  // Artifacts Box
  drawSectionBox(
    margin + boxWidth + 16,
    currentY,
    boxWidth,
    boxHeight,
    colors.sectionBg,
    colors.accentBlue
  );
  doc
    .fontSize(13)
    .font('Helvetica-Bold')
    .fillColor(colors.accentBlue)
    .text('Artifacts', margin + boxWidth + 23, currentY + 12);

  let artY = currentY + 35;
  (quote.inputs.artifacts || []).forEach((artifact: string) => {
    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.darkText)
      .text(`• ${artifact}`, margin + boxWidth + 23, artY);
    artY += itemLineH;
  });

  currentY += boxHeight + 25;

  // ============ FEATURE BREAKDOWN (DYNAMIC) ============
  const featureGroups = quote.inputs.features.reduce((acc: any, f: any) => {
    if (!acc[f.depth]) acc[f.depth] = [];
    acc[f.depth].push(capitalizeFirstWord(f.key));
    return acc;
  }, {});

  const depthColors: any = {
    basic: colors.accentGreen,
    standard: colors.accentBlue,
    advanced: colors.accentPurple,
  };

  // Calculate required height for feature header
  const featureHeaderHeight = 40;
  ensureSpace(featureHeaderHeight + 60, 'PROJECT SCOPE');

  renderSectionHeader('Feature Breakdown', {
    fontSize: 14,
    showDivider: true,
    sectionTitle: 'PROJECT SCOPE',
  });

  // Render each feature group dynamically
  Object.entries(featureGroups).forEach(([depth, features]: [string, any], groupIdx) => {
    const groupHeaderHeight = 30;
    const featuresHeight = (features as string[]).length * 18;
    const totalGroupHeight = groupHeaderHeight + featuresHeight + 15;

    // Check if we can fit at least the header + a few features
    const minGroupHeight = groupHeaderHeight + Math.min((features as string[]).length, 3) * 18;

    if (!hasSpaceFor(minGroupHeight)) {
      addScopeContinuationPage('FEATURE BREAKDOWN');
    }

    // Render group header
    if (groupIdx > 0) {
      currentY += 10;
    }

    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .fillColor(depthColors[depth] || colors.primary)
      .text(`${depth.toUpperCase()} FEATURES`, margin, currentY);

    currentY += 18;

    // Render features with page break handling
    (features as string[]).forEach((feature: string) => {
      const featureText = `• ${feature}`;
      const featureHeight = measureTextHeight(featureText, 11, 'Helvetica', contentWidth - 10, 2);
      const requiredHeight = Math.max(18, featureHeight + 4);

      if (!hasSpaceFor(requiredHeight)) {
        addScopeContinuationPage('FEATURE BREAKDOWN');
      }

      doc
        .fontSize(11)
        .font('Helvetica')
        .fillColor(colors.darkText)
        .text(featureText, margin + 10, currentY, {
          width: contentWidth - 10,
          lineGap: 2,
        });

      currentY = doc.y + 4;
    });
  });

  currentY += 15;

  // ============ TECHNICAL SPECIFICATIONS (DYNAMIC) ============
  const techSpecsHeight = 120;
  ensureSpace(techSpecsHeight, 'PROJECT SCOPE');

  renderSectionHeader('Technical Specifications', {
    fontSize: 14,
    showDivider: true,
    sectionTitle: 'PROJECT SCOPE',
  });

  const techSpecs = [
    { label: 'Scale Band', value: quote.inputs.scaleBand },
    { label: 'Accessibility', value: quote.inputs.a11y ? 'Required' : 'Standard' },
    { label: 'Multi-language', value: quote.inputs.i18n ? 'Yes' : 'No' },
    { label: 'Performance', value: quote.inputs.perf ? 'Optimized' : 'Standard' },
    { label: 'Compliance', value: quote.inputs.compliance.toUpperCase() },
    {
      label: 'AI Integration',
      value: quote.inputs.includesAI ? `${quote.inputs.aiNovelty || 'standard'}` : 'No',
    },
  ];

  techSpecs.forEach((spec, idx) => {
    const rowHeight = 26;

    if (!hasSpaceFor(rowHeight)) {
      addScopeContinuationPage('TECHNICAL SPECIFICATIONS');
    }

    const xPos = idx % 2 === 0 ? margin : margin + contentWidth / 2 + 10;
    const yPos = idx % 2 === 0 ? currentY : currentY;

    doc.fontSize(11).font('Helvetica').fillColor(colors.mediumText).text(spec.label, xPos, yPos);

    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .fillColor(colors.primary)
      .text(spec.value, xPos + 130, yPos);

    if (idx % 2 === 1 || idx === techSpecs.length - 1) {
      currentY += rowHeight;
    }
  });

  currentY += 20;

  // ============ TECHNOLOGY STACK (DYNAMIC) ============
  const techStackHeight = 100;
  ensureSpace(techStackHeight, 'PROJECT SCOPE');

  renderSectionHeader('Technology Stack', {
    fontSize: 14,
    showDivider: false,
    sectionTitle: 'PROJECT SCOPE',
  });

  drawSectionBox(margin, currentY, contentWidth, 65, colors.sectionBg, colors.primary);

  const stackItems = [
    { label: 'Frontend', value: quote.inputs.techPrefs.frontend },
    { label: 'Backend', value: quote.inputs.techPrefs.backend },
    { label: 'Database', value: quote.inputs.techPrefs.db },
    { label: 'Cloud', value: quote.inputs.techPrefs.cloud },
  ];

  stackItems.forEach((item, idx) => {
    const xPos = idx % 2 === 0 ? margin + 15 : margin + contentWidth / 2 + 15;
    const yPos = currentY + 15 + Math.floor(idx / 2) * 24;

    doc.fontSize(11).font('Helvetica').fillColor(colors.mediumText).text(item.label, xPos, yPos);

    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .fillColor(colors.primary)
      .text(item.value, xPos + 90, yPos);
  });

  currentY += 85;

  // Add footer to scope page(s) before moving to pricing
  addFooterToCurrentPage();

  // ============ PRICING & OPTIONS PAGE ============
  doc.addPage();
  currentPageNumber++;
  currentY = margin;

  doc
    .fontSize(24)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text('PRICING & OPTIONS', margin, currentY);

  currentY += 32;
  drawDivider(currentY, colors.primary, 2);
  currentY += 20;

  doc
    .fontSize(11)
    .font('Helvetica')
    .fillColor(colors.mediumText)
    .text(
      'Three tailored options designed to match your priorities. Each includes comprehensive development, testing, deployment, and post-launch support.',
      margin,
      currentY,
      { width: contentWidth, lineGap: 3 }
    );

  currentY += 35;

  // Option Cards
  const optionConfigs = [
    { key: 'A', color: colors.accentGreen, label: 'COST OPTIMIZED' },
    { key: 'B', color: colors.accentBlue, label: 'BALANCED' },
    { key: 'C', color: colors.accentPurple, label: 'FAST TRACK' },
  ];

  optionConfigs.forEach((optConfig, idx) => {
    const opt = (quote.options as any)[optConfig.key];
    const cardHeight = 110;

    // Check if we need a new page for this option card
    if (!hasSpaceFor(cardHeight + 20)) {
      addFooterToCurrentPage();
      doc.addPage();
      currentPageNumber++;
      currentY = margin;

      doc
        .fontSize(16)
        .font('Helvetica-Bold')
        .fillColor(colors.primary)
        .text('PRICING & OPTIONS (CONTINUED)', margin, currentY);

      currentY += 25;
      drawDivider(currentY);
      currentY += 15;
    }

    const cardY = currentY;

    // Card border
    doc
      .strokeColor(optConfig.color)
      .lineWidth(1)
      .roundedRect(margin, cardY, contentWidth, cardHeight, 0)
      .stroke();

    // Top colored bar
    doc.rect(margin, cardY, contentWidth, 30).fill(optConfig.color);
    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .fillColor(colors.white)
      .text(optConfig.label, margin + 15, cardY + 10, { width: contentWidth - 30 });

    // Recommended badge
    if (opt.recommended) {
      doc.roundedRect(pageWidth - margin - 112, cardY + 6, 95, 18, 9).fill(colors.white);
      doc
        .fontSize(10)
        .font('Helvetica-Bold')
        .fillColor(optConfig.color)
        .text('RECOMMENDED', pageWidth - margin - 105, cardY + 11);
    }

    // Content
    const contentY = cardY + 40;

    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.mediumText)
      .text('Timeline:', margin + 15, contentY);
    doc
      .fontSize(12)
      .font('Helvetica-Bold')
      .fillColor(colors.darkText)
      .text(`${opt.weeks} weeks`, margin + 85, contentY);

    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.mediumText)
      .text('Project Cost:', margin + 200, contentY);

    function formatIndianAmount(amount: number): string {
      if (amount >= 100000) {
        return `${(amount / 100000).toFixed(1)}L`;
      }
      if (amount >= 1000) {
        return `${(amount / 1000).toFixed(0)}K`;
      }
      return amount.toString();
    }

    const minFormatted = formatIndianAmount(opt.costMin);
    const maxFormatted = formatIndianAmount(opt.costMax);

    drawRupeesText(`₹${minFormatted} - ₹${maxFormatted}`, margin + 290, contentY - 4.5, {
      fontSize: 12,
      fillColor: colors.darkText,
    });

    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.mediumText)
      .text('Cloud Infra (monthly):', margin + 15, contentY + 25);

    drawRupeesText(`₹${opt.cloudMonthly.toLocaleString()}`, margin + 125, contentY + 23, {
      fontSize: 11,
      fillColor: colors.darkText,
    });

    const teamText = opt.team.map((t: any) => `${t.count}× ${t.role}`).join(' • ');
    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.lightText)
      .text(teamText, margin + 15, contentY + 50, { width: contentWidth - 30, lineGap: 2 });

    currentY += cardHeight + 10;
  });

  addFooterToCurrentPage();

  // ============ TERMS & CONDITIONS PAGE ============
  doc.addPage();
  currentPageNumber++;
  currentY = margin;

  doc
    .fontSize(24)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text('TERMS & CONDITIONS', margin, currentY);

  currentY += 32;
  drawDivider(currentY, colors.primary, 2);
  currentY += 20;

  // Assumptions
  renderSectionHeader('Assumptions', {
    fontSize: 13,
    showDivider: true,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  renderListWithPageBreaks(quote.assumptions, {
    fontSize: 11,
    font: 'Helvetica',
    color: colors.mediumText,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  currentY += 12;

  // Exclusions
  ensureSpace(60, 'TERMS & CONDITIONS');

  renderSectionHeader('Exclusions', {
    fontSize: 13,
    showDivider: true,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  renderListWithPageBreaks(quote.exclusions, {
    fontSize: 11,
    font: 'Helvetica',
    color: colors.mediumText,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  currentY += 12;

  // IP & Code Ownership
  ensureSpace(100, 'TERMS & CONDITIONS');

  renderSectionHeader('IP & Code Ownership', {
    fontSize: 13,
    showDivider: true,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  const ipText =
    'Upon full payment, all source code, documentation, and intellectual property rights developed for this project will be transferred to the client. Trakshym retains rights to pre-existing frameworks, libraries, and reusable components.';

  renderTextWithPageBreaks(ipText, {
    fontSize: 11,
    font: 'Helvetica',
    color: colors.mediumText,
    lineGap: 3,
    align: 'justify',
    sectionTitle: 'TERMS & CONDITIONS',
  });

  currentY += 18;

  // Payment Terms
  ensureSpace(120, 'TERMS & CONDITIONS');

  renderSectionHeader('Payment Terms (Milestone-based)', {
    fontSize: 13,
    showDivider: true,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  drawSectionBox(margin, currentY, contentWidth, 75, colors.sectionBg, colors.accentBlue);

  const milestones = [
    { phase: 'Kickoff', pct: '30%', desc: 'Upon agreement' },
    { phase: 'Development', pct: '40%', desc: 'After UAT approval' },
    { phase: 'Completion', pct: '30%', desc: 'Final delivery' },
  ];

  milestones.forEach((m, idx) => {
    const xPos = margin + idx * (contentWidth / 3) + 15;
    const yPos = currentY + 18;

    doc.fontSize(12).font('Helvetica-Bold').fillColor(colors.accentBlue).text(m.pct, xPos, yPos);

    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor(colors.darkText)
      .text(m.phase, xPos, yPos + 18);

    doc
      .fontSize(10)
      .font('Helvetica-Oblique')
      .fillColor(colors.lightText)
      .text(m.desc, xPos, yPos + 34);
  });

  currentY += 90;

  // Post-Launch Support
  ensureSpace(80, 'TERMS & CONDITIONS');

  renderSectionHeader('Post-Launch Support', {
    fontSize: 13,
    showDivider: true,
    sectionTitle: 'TERMS & CONDITIONS',
  });

  const supportText = `${quote.inputs.supportMonths} months of complimentary support. Critical issues: 4-hour response. Standard issues: 24-hour response (business days). Covers bug fixes, minor adjustments, and technical assistance.`;

  renderTextWithPageBreaks(supportText, {
    fontSize: 11,
    font: 'Helvetica',
    color: colors.mediumText,
    lineGap: 3,
    align: 'justify',
    sectionTitle: 'TERMS & CONDITIONS',
  });

  addFooterToCurrentPage();

  // ============ CTA & QR CODE PAGE ============
  doc.addPage();
  currentPageNumber++;
  currentY = margin + 50;

  doc
    .fontSize(32)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text("LET'S BUILD", margin, currentY, { width: contentWidth, align: 'center' });

  currentY += 42;
  doc
    .fontSize(32)
    .font('Helvetica-Bold')
    .fillColor(colors.primary)
    .text('THIS TOGETHER!', margin, currentY, { width: contentWidth, align: 'center' });

  currentY += 80;

  drawSectionBox(
    margin + 40,
    currentY,
    contentWidth - 80,
    135,
    colors.sectionBg,
    colors.primary,
    15
  );

  doc
    .fontSize(12)
    .font('Helvetica')
    .fillColor(colors.darkText)
    .text(
      "Thank you for considering Trakshym! We're excited to bring your vision to life.",
      margin + 55,
      currentY + 25,
      { width: contentWidth - 110, align: 'center', lineGap: 4 }
    );

  doc
    .fontSize(11)
    .font('Helvetica')
    .fillColor(colors.mediumText)
    .text('To discuss this quote or schedule a consultation:', margin + 55, currentY + 65, {
      width: contentWidth - 110,
      align: 'center',
      lineGap: 3,
    });

  doc
    .fontSize(14)
    .font('NotoSans')
    .fillColor(colors.primary)
    .text('contact@trakshym.com', margin + 55, currentY + 95, {
      width: contentWidth - 110,
      align: 'center',
    });

  currentY += 190;

  // QR Code
  const qrSize = 140;
  const qrX = margin + contentWidth / 2 - qrSize / 2;

  try {
    const qrImage = (doc as any).openImage(qrBuffer);

    doc.save();
    doc.roundedRect(qrX - 2, currentY - 2, qrSize + 4, qrSize + 4, 10).clip();
    doc.image(qrImage, qrX, currentY, {
      width: qrSize,
      height: qrSize,
    });
    doc.restore();
  } catch (err) {
    console.error('QR draw failed, drawing placeholder:', err);
    doc
      .strokeColor(colors.primary)
      .lineWidth(1)
      .roundedRect(qrX, currentY, qrSize, qrSize, 10)
      .stroke();
  }

  doc
    .fontSize(11)
    .font('Helvetica')
    .fillColor(colors.lightText)
    .text('Scan to schedule a call', margin, currentY + qrSize + 15, {
      width: contentWidth,
      align: 'center',
    });

  currentY += qrSize + 40;

  doc
    .fontSize(11)
    .font('Helvetica-Oblique')
    .fillColor(colors.mediumText)
    .text('This quote is valid for 30 days from the date of generation.', margin, currentY, {
      width: contentWidth,
      align: 'center',
      lineGap: 3,
    });

  doc
    .fontSize(11)
    .font('Helvetica-Oblique')
    .fillColor(colors.mediumText)
    .text('All prices in INR and exclusive of applicable taxes.', margin, currentY + 15, {
      width: contentWidth,
      align: 'center',
    });

  addFooterToCurrentPage();

  const finalPageCount = actualPageCount + 1;
  // console.log('[buildQuotePdf] Final page count:', finalPageCount);
};